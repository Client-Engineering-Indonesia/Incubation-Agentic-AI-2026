# Module 2.3: Create Python-Based Tool

---

## Overview

In this module, you'll learn how to create a Python-based tool that executes SQL queries on a PostgreSQL database and import it into watsonx Orchestrate. This tool accepts SQL statements as input and returns query results, allowing AI agents to dynamically query database information.

**Duration:** ~40 minutes

**Learning Objectives:**
- Create a Python function that accepts SQL queries as input
- Execute SQL queries on PostgreSQL database
- Package the function as a watsonx Orchestrate tool
- Import the tool into watsonx Orchestrate
- Test the tool functionality

---

## Prerequisites

Before starting this module, ensure you have:
- ✅ Completed **Module 2.1: Creating Connection**
- ✅ Completed **Module 2.2: Install ADK**
- ✅ Access to a PostgreSQL database
- ✅ Database credentials (host, port, database name, username, password)
- ✅ Python environment with ADK installed

---

## Part 1: Create Python Function to Retrieve Dataset from PostgreSQL

### Step 1: Install Required Dependencies

First, install the PostgreSQL adapter for Python:

```bash
# Activate your virtual environment
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install psycopg2 (PostgreSQL adapter)
pip install psycopg2-binary

# Install python-dotenv for environment variables
pip install python-dotenv
```

![Install Dependencies](images/2.3-01-install-dependencies.png)

---

### Step 2: Set Up Database Configuration

Add your PostgreSQL credentials to the `.env` file:

```bash
# PostgreSQL Database Configuration
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_DATABASE=your_database_name
POSTGRES_USER=your_username
POSTGRES_PASSWORD=your_password
```

![Database Configuration](images/2.3-02-database-config.png)

---

### Step 3: Create Database Query Function

Create a new file `tools/postgres_query_tool.py`:

```python
"""
PostgreSQL Query Tool for executing SQL statements.
This tool accepts SQL queries as input and returns results.
"""

import os
import psycopg2
from psycopg2.extras import RealDictCursor
from dotenv import load_dotenv
from typing import Dict, Any, List, Optional
import json

# Load environment variables
load_dotenv()


class PostgreSQLQueryExecutor:
    """Executes SQL queries on PostgreSQL database."""
    
    def __init__(self):
        """Initialize database connection parameters."""
        self.host = os.getenv('POSTGRES_HOST', 'localhost')
        self.port = os.getenv('POSTGRES_PORT', '5432')
        self.database = os.getenv('POSTGRES_DATABASE')
        self.user = os.getenv('POSTGRES_USER')
        self.password = os.getenv('POSTGRES_PASSWORD')
        self.connection = None
    
    def connect(self) -> bool:
        """
        Establish connection to PostgreSQL database.
        
        Returns:
            bool: True if connection successful, False otherwise
        """
        try:
            self.connection = psycopg2.connect(
                host=self.host,
                port=self.port,
                database=self.database,
                user=self.user,
                password=self.password,
                connect_timeout=10
            )
            return True
        except Exception as e:
            print(f"Error connecting to database: {e}")
            return False
    
    def disconnect(self):
        """Close database connection."""
        if self.connection:
            self.connection.close()
            self.connection = None
    
    def is_safe_query(self, sql: str) -> tuple[bool, str]:
        """
        Check if SQL query is safe to execute (read-only).
        
        Args:
            sql: SQL query string
            
        Returns:
            tuple: (is_safe, error_message)
        """
        # Convert to uppercase for checking
        sql_upper = sql.strip().upper()
        
        # List of dangerous SQL keywords
        dangerous_keywords = [
            'DROP', 'DELETE', 'TRUNCATE', 'ALTER', 
            'CREATE', 'INSERT', 'UPDATE', 'GRANT', 
            'REVOKE', 'EXEC', 'EXECUTE'
        ]
        
        # Check for dangerous keywords
        for keyword in dangerous_keywords:
            if sql_upper.startswith(keyword):
                return False, f"Query contains forbidden keyword: {keyword}"
        
        # Must start with SELECT
        if not sql_upper.startswith('SELECT'):
            return False, "Only SELECT queries are allowed"
        
        return True, ""


def execute_sql_query(sql_query: str, max_rows: int = 100) -> Dict[str, Any]:
    """
    Execute a SQL query on PostgreSQL database and return results.
    
    Args:
        sql_query: SQL SELECT statement to execute
        max_rows: Maximum number of rows to return (default: 100)
        
    Returns:
        Dictionary containing query results or error information
        
    Example:
        >>> result = execute_sql_query("SELECT * FROM customers LIMIT 5")
        >>> print(result)
        {
            "success": True,
            "row_count": 5,
            "columns": ["customer_id", "customer_name", "email"],
            "data": [...]
        }
    """
    executor = PostgreSQLQueryExecutor()
    
    try:
        # Validate SQL query
        is_safe, error_msg = executor.is_safe_query(sql_query)
        if not is_safe:
            return {
                "success": False,
                "error": f"Query validation failed: {error_msg}",
                "sql_query": sql_query
            }
        
        # Connect to database
        if not executor.connect():
            return {
                "success": False,
                "error": "Failed to connect to database",
                "sql_query": sql_query
            }
        
        # Execute query
        cursor = executor.connection.cursor(cursor_factory=RealDictCursor)
        cursor.execute(sql_query)
        
        # Fetch results (limited by max_rows)
        results = cursor.fetchmany(max_rows)
        
        # Get column names
        columns = [desc[0] for desc in cursor.description] if cursor.description else []
        
        # Convert results to list of dictionaries
        data = [dict(row) for row in results]
        
        # Get total row count if available
        row_count = len(data)
        
        cursor.close()
        
        return {
            "success": True,
            "sql_query": sql_query,
            "row_count": row_count,
            "columns": columns,
            "data": data,
            "message": f"Query executed successfully. Returned {row_count} rows."
        }
        
    except psycopg2.Error as e:
        return {
            "success": False,
            "error": f"Database error: {str(e)}",
            "sql_query": sql_query,
            "error_code": e.pgcode if hasattr(e, 'pgcode') else None
        }
    except Exception as e:
        return {
            "success": False,
            "error": f"Unexpected error: {str(e)}",
            "sql_query": sql_query
        }
    finally:
        executor.disconnect()


def query_database(sql_query: str) -> Dict[str, Any]:
    """
    Simplified wrapper for execute_sql_query.
    Main function to be exposed to watsonx Orchestrate.
    
    Args:
        sql_query: SQL SELECT statement to execute
        
    Returns:
        Dictionary containing query results
    """
    return execute_sql_query(sql_query, max_rows=100)


# Test the function
if __name__ == "__main__":
    print("Testing PostgreSQL Query Tool...\n")
    print("=" * 60)
    
    # Test 1: Simple SELECT query
    print("\n1. Test: Simple SELECT query")
    print("-" * 60)
    sql1 = "SELECT * FROM customers LIMIT 5"
    print(f"SQL: {sql1}")
    result1 = query_database(sql1)
    print(f"Result: {json.dumps(result1, indent=2, default=str)}\n")
    
    # Test 2: SELECT with WHERE clause
    print("\n2. Test: SELECT with WHERE clause")
    print("-" * 60)
    sql2 = "SELECT customer_name, email, city FROM customers WHERE country = 'USA' LIMIT 10"
    print(f"SQL: {sql2}")
    result2 = query_database(sql2)
    print(f"Result: {json.dumps(result2, indent=2, default=str)}\n")
    
    # Test 3: SELECT with JOIN
    print("\n3. Test: SELECT with JOIN")
    print("-" * 60)
    sql3 = """
        SELECT c.customer_name, c.email, COUNT(o.order_id) as order_count
        FROM customers c
        LEFT JOIN orders o ON c.customer_id = o.customer_id
        GROUP BY c.customer_id, c.customer_name, c.email
        LIMIT 5
    """
    print(f"SQL: {sql3}")
    result3 = query_database(sql3)
    print(f"Result: {json.dumps(result3, indent=2, default=str)}\n")
    
    # Test 4: Invalid query (should fail)
    print("\n4. Test: Invalid query (DELETE - should fail)")
    print("-" * 60)
    sql4 = "DELETE FROM customers WHERE customer_id = 1"
    print(f"SQL: {sql4}")
    result4 = query_database(sql4)
    print(f"Result: {json.dumps(result4, indent=2, default=str)}\n")
    
    print("=" * 60)
    print("Testing complete!")
```

![Create Query Tool](images/2.3-03-create-query-tool.png)

---

### Step 4: Test the Python Function Locally

Test your function before importing to watsonx Orchestrate:

```bash
# Run the test
python tools/postgres_query_tool.py
```

**Expected Output:**
```
Testing PostgreSQL Query Tool...

============================================================

1. Test: Simple SELECT query
------------------------------------------------------------
SQL: SELECT * FROM customers LIMIT 5
Result: {
  "success": true,
  "sql_query": "SELECT * FROM customers LIMIT 5",
  "row_count": 5,
  "columns": ["customer_id", "customer_name", "email", "phone", "city", "country"],
  "data": [
    {
      "customer_id": 1,
      "customer_name": "John Doe",
      "email": "john@example.com",
      "phone": "+1234567890",
      "city": "New York",
      "country": "USA"
    },
    ...
  ],
  "message": "Query executed successfully. Returned 5 rows."
}

2. Test: SELECT with WHERE clause
------------------------------------------------------------
SQL: SELECT customer_name, email, city FROM customers WHERE country = 'USA' LIMIT 10
Result: {
  "success": true,
  "row_count": 10,
  ...
}

3. Test: SELECT with JOIN
------------------------------------------------------------
SQL: SELECT c.customer_name, c.email, COUNT(o.order_id) as order_count...
Result: {
  "success": true,
  "row_count": 5,
  ...
}

4. Test: Invalid query (DELETE - should fail)
------------------------------------------------------------
SQL: DELETE FROM customers WHERE customer_id = 1
Result: {
  "success": false,
  "error": "Query validation failed: Query contains forbidden keyword: DELETE",
  "sql_query": "DELETE FROM customers WHERE customer_id = 1"
}

============================================================
Testing complete!
```

![Test Query Tool](images/2.3-04-test-query-tool.png)

---

## Part 2: Import Function to watsonx Orchestrate

### Step 5: Create Tool Definition File

Create a tool definition file that describes your tool for watsonx Orchestrate:

**File: `tools/postgres_query_tool_definition.yaml`**

```yaml
# Tool Definition for PostgreSQL Query Tool
name: postgres_query_tool
display_name: PostgreSQL Query Tool
description: Execute SQL SELECT queries on PostgreSQL database and retrieve results
version: 1.0.0

# Tool function
functions:
  - name: query_database
    display_name: Query Database
    description: |
      Execute a SQL SELECT query on PostgreSQL database.
      Only SELECT queries are allowed for security.
      Returns query results as structured data.
    parameters:
      - name: sql_query
        type: string
        description: |
          SQL SELECT statement to execute.
          Example: "SELECT * FROM customers WHERE city = 'New York' LIMIT 10"
        required: true
        example: "SELECT customer_id, customer_name, email FROM customers LIMIT 5"
    returns:
      type: object
      description: Query results with success status, row count, columns, and data
      properties:
        success:
          type: boolean
          description: Whether the query executed successfully
        sql_query:
          type: string
          description: The SQL query that was executed
        row_count:
          type: integer
          description: Number of rows returned
        columns:
          type: array
          description: List of column names in the result
        data:
          type: array
          description: Array of result rows as objects
        message:
          type: string
          description: Success or error message

# Connection requirements
connections:
  - name: postgres_connection
    type: postgresql
    required: true
    description: PostgreSQL database connection

# Security settings
security:
  read_only: true
  allowed_operations:
    - SELECT
  forbidden_operations:
    - INSERT
    - UPDATE
    - DELETE
    - DROP
    - CREATE
    - ALTER
    - TRUNCATE

# Tags for organization
tags:
  - database
  - postgresql
  - sql
  - query
  - data-retrieval

# Usage examples
examples:
  - name: Get all customers
    description: Retrieve all customers from the database
    input:
      sql_query: "SELECT * FROM customers LIMIT 10"
    
  - name: Search by city
    description: Find customers in a specific city
    input:
      sql_query: "SELECT customer_name, email FROM customers WHERE city = 'New York'"
    
  - name: Join tables
    description: Get customer orders with JOIN
    input:
      sql_query: |
        SELECT c.customer_name, o.order_id, o.total_amount
        FROM customers c
        JOIN orders o ON c.customer_id = o.customer_id
        LIMIT 20
```

![Tool Definition](images/2.3-05-tool-definition.png)

---

### Step 6: Create Tool Package

Create a package structure for your tool:

```bash
# Create tool package directory
mkdir -p tool_package/postgres_query_tool

# Copy files to package
cp tools/postgres_query_tool.py tool_package/postgres_query_tool/
cp tools/postgres_query_tool_definition.yaml tool_package/postgres_query_tool/

# Create __init__.py
cat > tool_package/postgres_query_tool/__init__.py << 'EOF'
"""PostgreSQL Query Tool Package for watsonx Orchestrate."""

from .postgres_query_tool import query_database

__all__ = ['query_database']
EOF

# Create requirements.txt for the tool
cat > tool_package/postgres_query_tool/requirements.txt << 'EOF'
psycopg2-binary>=2.9.0
python-dotenv>=1.0.0
EOF

# Create README for the tool
cat > tool_package/postgres_query_tool/README.md << 'EOF'
# PostgreSQL Query Tool

Execute SQL SELECT queries on PostgreSQL database.

## Features
- Execute SELECT queries dynamically
- Security validation (read-only)
- Returns structured JSON results
- Maximum 100 rows per query

## Usage
```python
from postgres_query_tool import query_database

result = query_database("SELECT * FROM customers LIMIT 5")
print(result)
```

## Security
- Only SELECT queries allowed
- Dangerous keywords blocked (DELETE, DROP, etc.)
- Connection timeout: 10 seconds
- Maximum rows: 100
EOF
```

![Create Tool Package](images/2.3-06-create-package.png)

---

### Step 7: Import Tool Using ADK CLI

Use the ADK command-line interface to import your tool:

```bash
# Navigate to tool package directory
cd tool_package

# Import tool to watsonx Orchestrate using Python script
python << 'EOF'
from ibm_watsonx_orchestrate_adk import ToolImporter
import os
from dotenv import load_dotenv

load_dotenv()

# Initialize importer
importer = ToolImporter(
    api_key=os.getenv('WATSONX_ORCHESTRATE_API_KEY'),
    instance_id=os.getenv('WATSONX_ORCHESTRATE_INSTANCE_ID'),
    region=os.getenv('WATSONX_ORCHESTRATE_REGION')
)

print("Importing PostgreSQL Query Tool...")
print("=" * 60)

# Import tool
result = importer.import_tool(
    tool_path='postgres_query_tool',
    tool_name='postgres_query_tool',
    connection_name='postgres_connection'
)

if result['success']:
    print("\n✅ Tool imported successfully!")
    print(f"Tool ID: {result['tool_id']}")
    print(f"Tool Name: {result['tool_name']}")
    print(f"Functions: {', '.join(result['functions'])}")
else:
    print(f"\n❌ Import failed: {result['error']}")

print("=" * 60)
EOF
```

**Expected Output:**
```
Importing PostgreSQL Query Tool...
============================================================
Validating tool definition...
✅ Tool definition valid
Uploading tool package...
✅ Tool package uploaded (2.3 KB)
Registering tool functions...
✅ Function registered: query_database
Creating tool in watsonx Orchestrate...
✅ Tool created successfully

✅ Tool imported successfully!
Tool ID: tool_postgres_query_abc123
Tool Name: postgres_query_tool
Functions: query_database
============================================================
```

![Import Tool](images/2.3-07-import-tool.png)

---

### Step 8: Verify Tool Import in watsonx Orchestrate UI

Verify the tool was imported successfully:

1. Log in to **watsonx Orchestrate**
2. Navigate to **Tools** or **Integrations**
3. Find your **PostgreSQL Query Tool**
4. Click on it to view details

**You should see:**
- Tool name: PostgreSQL Query Tool
- Description: Execute SQL SELECT queries on PostgreSQL database
- Function: query_database
- Parameter: sql_query (string, required)
- Connection requirement: postgres_connection
- Status: Active

![Verify Tool Import](images/2.3-08-verify-import.png)

---

### Step 9: Test Tool in watsonx Orchestrate

Test your imported tool directly in watsonx Orchestrate:

#### Test 1: Simple SELECT Query

1. Go to **Tools** → **PostgreSQL Query Tool**
2. Click **Test** or **Try it**
3. Select function: **query_database**
4. Enter SQL query:
   ```sql
   SELECT * FROM customers LIMIT 5
   ```
5. Click **Run**

**Expected Response:**
```json
{
  "success": true,
  "sql_query": "SELECT * FROM customers LIMIT 5",
  "row_count": 5,
  "columns": [
    "customer_id",
    "customer_name",
    "email",
    "phone",
    "city",
    "country",
    "created_at"
  ],
  "data": [
    {
      "customer_id": 1,
      "customer_name": "John Doe",
      "email": "john@example.com",
      "phone": "+1234567890",
      "city": "New York",
      "country": "USA",
      "created_at": "2024-01-15T10:30:00"
    },
    ...
  ],
  "message": "Query executed successfully. Returned 5 rows."
}
```

![Test Simple Query](images/2.3-09-test-simple-query.png)

---

#### Test 2: SELECT with WHERE Clause

Enter SQL query:
```sql
SELECT customer_name, email, city 
FROM customers 
WHERE country = 'USA' 
ORDER BY customer_name 
LIMIT 10
```

**Expected Response:**
```json
{
  "success": true,
  "sql_query": "SELECT customer_name, email, city FROM customers WHERE country = 'USA' ORDER BY customer_name LIMIT 10",
  "row_count": 10,
  "columns": ["customer_name", "email", "city"],
  "data": [
    {
      "customer_name": "Alice Johnson",
      "email": "alice@example.com",
      "city": "Los Angeles"
    },
    ...
  ],
  "message": "Query executed successfully. Returned 10 rows."
}
```

![Test WHERE Query](images/2.3-10-test-where-query.png)

---

#### Test 3: SELECT with JOIN

Enter SQL query:
```sql
SELECT 
    c.customer_name, 
    c.email, 
    COUNT(o.order_id) as total_orders,
    SUM(o.total_amount) as total_spent
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.customer_name, c.email
ORDER BY total_spent DESC
LIMIT 10
```

**Expected Response:**
```json
{
  "success": true,
  "row_count": 10,
  "columns": ["customer_name", "email", "total_orders", "total_spent"],
  "data": [
    {
      "customer_name": "John Doe",
      "email": "john@example.com",
      "total_orders": 15,
      "total_spent": 4599.85
    },
    ...
  ],
  "message": "Query executed successfully. Returned 10 rows."
}
```

![Test JOIN Query](images/2.3-11-test-join-query.png)

---

#### Test 4: Invalid Query (Security Test)

Enter SQL query:
```sql
DELETE FROM customers WHERE customer_id = 1
```

**Expected Response:**
```json
{
  "success": false,
  "error": "Query validation failed: Query contains forbidden keyword: DELETE",
  "sql_query": "DELETE FROM customers WHERE customer_id = 1"
}
```

This confirms the security validation is working correctly.

![Test Invalid Query](images/2.3-12-test-invalid-query.png)

---

### Step 10: Update Tool (if needed)

If you need to update your tool after making changes:

```bash
# Update the tool code
# Edit tools/postgres_query_tool.py

# Re-import the tool
python << 'EOF'
from ibm_watsonx_orchestrate_adk import ToolImporter
import os
from dotenv import load_dotenv

load_dotenv()

importer = ToolImporter(
    api_key=os.getenv('WATSONX_ORCHESTRATE_API_KEY'),
    instance_id=os.getenv('WATSONX_ORCHESTRATE_INSTANCE_ID'),
    region=os.getenv('WATSONX_ORCHESTRATE_REGION')
)

result = importer.update_tool(
    tool_id='tool_postgres_query_abc123',
    tool_path='postgres_query_tool'
)

if result['success']:
    print("✅ Tool updated successfully!")
    print(f"Version: {result['version']}")
else:
    print(f"❌ Update failed: {result['error']}")
EOF
```

![Update Tool](images/2.3-13-update-tool.png)

---

## Summary

In this module, you learned how to:

✅ **Create Python Function to Retrieve Dataset from PostgreSQL**
- Installed PostgreSQL adapter (psycopg2)
- Created `query_database()` function that accepts SQL queries as input
- Implemented security validation (read-only, SELECT queries only)
- Added error handling and connection management
- Tested function locally with various SQL queries

✅ **Import Function to watsonx Orchestrate**
- Created tool definition file (YAML) with function specification
- Packaged tool with proper structure
- Imported tool using ADK
- Verified tool in watsonx Orchestrate UI
- Tested tool with different SQL queries:
  - Simple SELECT
  - SELECT with WHERE clause
  - SELECT with JOIN and aggregation
  - Invalid queries (security validation)
- Learned how to update tools

**Key Features of the Tool:**
- Accepts any SQL SELECT query as input
- Returns structured JSON results
- Security validation prevents dangerous operations
- Maximum 100 rows per query
- Includes column names and row count
- Proper error handling

---

## Next Steps

Now that you've created and imported a Python-based tool that accepts SQL queries, you're ready to:

➡️ **[Module 2.4: Create Agent Using ADK](2.4-Create%20agent%20using%20ADK.md)**
- Create an agent programmatically
- Integrate your PostgreSQL query tool with the agent
- Enable the agent to query databases dynamically
- Deploy the agent to watsonx Orchestrate

---

[← Back to Module 2.2](2.2-Install%20ADK.md) | [Lab 3 Overview](README.md) | [Next: Module 2.4 →](2.4-Create%20agent%20using%20ADK.md)